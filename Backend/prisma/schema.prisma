generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========== ENUMS ==========

enum FlowStatus {
  ACTIVE
  INACTIVE
  DRAFT
}

enum RunStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// ========== NEW ENUMS FOR AI ==========

enum DBNodeMode {
  READ
  WRITE
  BOTH
}

enum LLMProvider {
  OPENAI     // GPT-4o, o1-preview, o1-mini
  GOOGLE     // Gemini 2.0, Gemini 1.5
}

// ========== EXISTING MODELS (KEEP AS IS) ==========

model ExecutionLog {
  id            String   @id @default(cuid())
  runId         String
  run           Run      @relation(fields: [runId], references: [id], onDelete: Cascade)
  nodeId        String
  level         String
  message       String
  metadata      String?
  timestamp     DateTime @default(now())

  @@index([runId])
  @@index([timestamp])
  @@index([level])
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  password  String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  heliusWebhooks  HeliusWebhook[] 
  // Relations
  flows       Flow[]
  credentials Credential[]
  runs        Run[]
  aiNodeConfigs  AINodeConfig[]
  postgresDBNodeConfigs PostgresDBNodeConfig[]
  aiMemories  AIMemory[]
  multisigProposals MultisigProposal[]
  votingProposals   VotingProposal[]
  escrowAccounts    EscrowAccount[]
}

model Credential {
  id       String   @id @default(uuid())
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name     String
  type     String  // ‚úÖ NEW: supports "llm_api", "postgres_db"
  data     Json    // Encrypted: { apiKey } OR { connectionUrl }
  
  isActive Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  flows Flow[]
  aiNodeConfigs AINodeConfig[]
  postgresDBNodeConfigs PostgresDBNodeConfig[]
  
  @@unique([userId, name])
  @@index([userId, type])
}

model Flow {
  id       String     @id @default(uuid())
  name     String
  userId   String
  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  json     Json
  status   FlowStatus @default(ACTIVE)
  
  schedule  String?
  lastRunAt DateTime?
  nextRunAt DateTime?
  
  heliusWebhooks  HeliusWebhook[] 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  runs        Run[]
  credentials Credential[]
  aiNodeConfigs  AINodeConfig[]
  postgresDBNodeConfigs PostgresDBNodeConfig[]
  aiMemories  AIMemory[]
  multisigProposals MultisigProposal[]
  votingProposals   VotingProposal[]
  escrowAccounts    EscrowAccount[]
  
  @@index([userId])
  @@index([status])
  @@index([nextRunAt])
}

model Run {
  id       String    @id @default(uuid())
  flowId   String
  flow     Flow      @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId   String
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  status   RunStatus @default(QUEUED)
  input    Json?
  output   Json?
  error    String?
  
  heliusEvents    HeliusWebhookEvent[]
  
  createdAt  DateTime   @default(now())
  startedAt  DateTime?
  finishedAt DateTime?
  updatedAt  DateTime   @updatedAt
  
  // Relations
  nodeOutputs NodeOutput[]
  logs ExecutionLog[]
  toolExecutionLogs ToolExecutionLog[]
  aiMemories  AIMemory[]
  
  @@index([userId])
  @@index([flowId])
  @@index([status])
  @@index([createdAt])
}

model NodeOutput {
  id        String   @id @default(uuid())
  runId     String
  run       Run      @relation(fields: [runId], references: [id], onDelete: Cascade)
  nodeId    String
  output    Json
  error     String?
  createdAt DateTime @default(now())
  
  @@index([runId])
  @@index([runId, nodeId])
}

model PendingTransaction {
  id        String   @id @default(cuid())
  userId    String
  flowRunId String
  
  type      String
  serializedTransaction String @db.Text
  transactionDetails Json
  
  status    String   @default("pending")
  
  approvedAt    DateTime?
  rejectedAt    DateTime?
  signature     String?
  
  expiresAt     DateTime
  approvalToken String @unique @default(cuid())
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
  @@index([approvalToken])
  @@index([status])
}

model WalletWatch {
  id                String   @id @default(cuid())
  flowId            String
  nodeId            String
  walletAddress     String
  watchType         String
  
  lastBalance       BigInt?
  lastTokenBalance  BigInt?
  lastSignature     String?
  tokenMint         String?
  lastCheckedAt     DateTime @default(now())
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@unique([flowId, nodeId, walletAddress])
  @@index([flowId])
  @@index([walletAddress])
}

// ========== NEW AI MODELS ==========

// 1Ô∏è‚É£ AI Node Configuration
model AINodeConfig {
  id            String      @id @default(uuid())
  
  // Node identification
  nodeId        String
  flowId        String
  flow          Flow        @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // LLM Configuration
  provider      LLMProvider
  credentialId  String
  credential    Credential  @relation(fields: [credentialId], references: [id], onDelete: Restrict)
  modelName     String      // e.g., "claude-sonnet-4", "gpt-4-turbo"
  
  // Prompts
  systemPrompt  String      @db.Text
  userGoal      String      @db.Text
  
  // Parameters
  temperature   Float       @default(0.7)
  maxTokens     Int         @default(4000)
  maxRetries    Int         @default(3)
  
  // üÜï HYBRID MEMORY CONFIG
  useUserDBForMemory  Boolean     @default(false)  // If true, use user's DB; if false, use AIMemory fallback
  memoryTableName     String?                      // Table name in user's DB (if useUserDBForMemory = true)
  
  // Metadata
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  toolExecutionLogs ToolExecutionLog[]
  aiMemories        AIMemory[]  // Fallback storage
  
  @@unique([flowId, nodeId])
  @@index([userId])
  @@index([flowId])
}

// 2Ô∏è‚É£ Postgres DB Node Configuration
model PostgresDBNodeConfig {
  id            String      @id @default(uuid())
  
  // Node identification
  nodeId        String
  flowId        String
  flow          Flow        @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Database Connection (reference to credential)
  credentialId  String
  credential    Credential  @relation(fields: [credentialId], references: [id], onDelete: Restrict)
  
  // Mode
  mode          DBNodeMode  @default(BOTH)
  
  // Schema Definition
  schema        Json        // { tables: [ { name: "trades", columns: { id: "uuid", amount: "numeric" } } ] }
  
  // Metadata
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  @@unique([flowId, nodeId])
  @@index([userId])
  @@index([flowId])
  @@index([mode])
}

// 3Ô∏è‚É£ AI Memory (FALLBACK ONLY)
// Used ONLY when useUserDBForMemory = false
model AIMemory {
  id            String      @id @default(uuid())
  
  // Ownership
  aiNodeId      String
  aiNodeConfig  AINodeConfig @relation(fields: [aiNodeId], references: [id], onDelete: Cascade)
  flowId        String
  flow          Flow        @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Execution reference
  runId         String
  run           Run         @relation(fields: [runId], references: [id], onDelete: Cascade)
  
  // Memory data
  data          Json
  summary       String?
  
  // üÜï TTL for auto-cleanup (24 hours)
  expiresAt     DateTime    @default(dbgenerated("NOW() + INTERVAL '24 hours'"))
  
  // Metadata
  createdAt     DateTime    @default(now())
  
  @@index([aiNodeId])
  @@index([flowId])
  @@index([userId])
  @@index([runId])
  @@index([createdAt])
  @@index([expiresAt])  // For cleanup queries
}

// 4Ô∏è‚É£ Tool Execution Log
model ToolExecutionLog {
  id            String      @id @default(uuid())
  
  // Ownership
  aiNodeId      String
  aiNodeConfig  AINodeConfig @relation(fields: [aiNodeId], references: [id], onDelete: Cascade)
  runId         String
  run           Run         @relation(fields: [runId], references: [id], onDelete: Cascade)
  
  // Tool details
  toolName      String      // e.g., "jupiter_get_quote", "postgres_query"
  toolType      String      // e.g., "jupiter", "pyth", "postgres", "http"
  
  // Execution data
  input         Json
  output        Json?
  error         String?     @db.Text
  
  // Status
  success       Boolean     @default(false)
  retryCount    Int         @default(0)
  duration      Int?        // milliseconds
  
  // Metadata
  timestamp     DateTime    @default(now())
  
  @@index([aiNodeId])
  @@index([runId])
  @@index([toolName])
  @@index([success])
  @@index([timestamp])
}

// ========== HELIUS WEBHOOK MODELS ==========

model HeliusWebhook {
  id                String   @id @default(uuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  flowId            String
  flow              Flow     @relation(fields: [flowId], references: [id], onDelete: Cascade)
  
  // Helius webhook details
  heliusWebhookId   String   @unique // Helius-generated webhook ID
  webhookURL        String   // URL where Helius sends events
  webhookType       String   // "enhanced", "raw", or "discord"
  transactionTypes  String[] // ["ANY", "NFT_SALE", "NFT_LISTING", etc.]
  accountAddresses  String[] // Solana addresses to monitor
  
  // Credentials
  credentialId      String   // Reference to Helius API key credential
  
  // Status
  isActive          Boolean  @default(true)
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastTriggered     DateTime?
  
  // Relations
  events            HeliusWebhookEvent[]
  
  @@index([userId])
  @@index([flowId])
  @@index([heliusWebhookId])
  @@index([isActive])
}

model HeliusWebhookEvent {
  id          String   @id @default(uuid())
  webhookId   String
  webhook     HeliusWebhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  
  // Event data from Helius
  signature   String?  // Transaction signature
  type        String   // Transaction type (NFT_SALE, SWAP, etc.)
  timestamp   DateTime // When the transaction occurred
  eventData   Json     // Full Helius event payload
  
  // Execution tracking
  runId       String?
  run         Run?     @relation(fields: [runId], references: [id])
  processed   Boolean  @default(false)
  error       String?  // Error message if processing failed
  
  createdAt   DateTime @default(now())
  
  @@index([webhookId])
  @@index([signature])
  @@index([processed])
  @@index([timestamp])
}

// ========== SMART CONTRACT NODES ==========

model MultisigProposal {
  id           String   @id // PDA address from contract
  flowId       String
  flow         Flow     @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Multisig details
  creator      String   // Creator's public key
  owners       String[] // Array of owner public keys (max 10)
  threshold    Int      // Required approvals
  description  String   // Proposal description
  
  // Public signing URL
  signingUrl   String?  // Generated URL for owners to approve/reject
  
  // Notification settings
  notifyEmail      String?  // Email to notify when created
  notifyTelegram   String?  // Telegram chat ID to notify
  
  // Status tracking
  status       String   // "pending", "approved", "rejected"
  approvals    String[] // Array of approving public keys
  rejections   String[] // Array of rejecting public keys
  executed     Boolean  @default(false)
  
  // Timestamps
  expiresAt    DateTime
  executedAt   DateTime?
  createdAt    DateTime @default(now())
  
  // Contract state
  seed         String   // Unique seed for PDA derivation
  bump         Int      // PDA bump seed
  
  @@index([flowId])
  @@index([userId])
  @@index([status])
  @@index([executed])
  @@index([expiresAt])
}

model VotingProposal {
  id             String   @id // PDA address from contract
  flowId         String
  flow           Flow     @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Voting details
  creator        String   // Creator's public key
  title          String   // Voting title
  description    String   // Voting description
  choices        String[] // Array of choice labels (2-10)
  voteCounts     Int[]    // Array of vote counts for each choice
  
  // Public voting URL
  votingUrl      String?  // Generated URL for voters
  
  // Notification settings
  notifyEmail      String?  // Email to notify when created
  notifyTelegram   String?  // Telegram chat ID to notify
  
  // Voter management
  allowedVoters  String[] // Optional whitelist (empty = public)
  voters         String[] // Addresses that have voted
  
  // Results
  finalized      Boolean  @default(false)
  winnerIndex    Int?     // Index of winning choice
  status         String   // "active", "finalized"
  
  // Timestamps
  expiresAt      DateTime
  finalizedAt    DateTime?
  createdAt      DateTime @default(now())
  
  // Contract state
  seed           String   // Unique seed for PDA derivation
  bump           Int      // PDA bump seed
  
  @@index([flowId])
  @@index([userId])
  @@index([status])
  @@index([finalized])
  @@index([expiresAt])
}

model EscrowAccount {
  id                  String   @id // PDA address from contract
  flowId              String
  flow                Flow     @relation(fields: [flowId], references: [id], onDelete: Cascade)
  userId              String
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Parties involved
  buyer               String   // Buyer's public key
  seller              String   // Seller's public key
  arbitrator          String?  // Optional arbitrator public key
  
  // Payment details
  amount              String   // Amount in lamports (stored as string for precision)
  description         String   // Escrow description
  disputeWindowDays   Int      // Days buyer has to approve/dispute (1-30)
  
  // Public escrow URL
  escrowUrl           String?  // Generated URL for parties to interact
  
  // Notification settings
  notifyEmail         String?  // Email to notify when created
  notifyTelegram      String?  // Telegram chat ID to notify
  
  // Status tracking
  status              String   // "Created", "SellerDelivered", "Disputed", "Resolved", "Cancelled"
  sellerDelivered     Boolean  @default(false)
  sellerDeliveredAt   DateTime?
  buyerApproved       Boolean  @default(false)
  
  // Dispute handling
  disputed            Boolean  @default(false)
  disputeRaisedAt     DateTime?
  disputeReason       String?
  winner              String?  // Public key of winner (buyer or seller)
  decidedAt           DateTime?
  
  // Timestamps
  createdAt           DateTime @default(now())
  
  // Contract state
  seed                String   // Unique seed for PDA derivation
  bump                Int      // PDA bump seed
  
  @@index([flowId])
  @@index([userId])
  @@index([status])
  @@index([disputed])
  @@index([buyer])
  @@index([seller])
}